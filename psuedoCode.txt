Create a node class 
    constructor = > ( data )
    properties => { data, rightKid, leftKid }
build a tree class  
    constructor => ( array )
    properties => {root =  (returned value of the buildTree function) }

create a function that takes an array of data and turns it into a balanced 
binary tree full of Node objects appropitalely placed (dont forget to sort and remove
duplicates) The function should return the level - 0 root node 

buildTree(array)
    Set the middle of the array 
    let root is going to be the root node of tree 
    Recursively get middle of the left and right subtree
    Return root 

create a function that inserts the given value into the array being inserted 
insert(value , currentNode = this.root) { 
    if root is null return a new node with the value inside of it 
    if value is less than the root value ; run the insert method recursively for the left side of the root
        assign currentNode.left to the insert function with the value and currentNode left as the parameters 
    if value is more than the root value; run the insert method recursively for the right side of the root
        assign currentNode.right to the insert function with the value and currentNode right as the parameters 
    return currentNode 
}


create min function that returns the smallest value in the tree {

min(root) { 
    check root.left to see if it is null 
        if null then return the root.value 
        else return rootl.left recursively 
}

create max function that returns the largest value in the tree 

max(root) 
    check root.right to see if it is null 
    if null then return the root.value 
    else return the root.right recursively

create a function that will delete a node in the tree 
delete(value) { 
    assign root to run deleteNode function recursively with (root , value) as constructors 

}

deleteNode(value, root){ 
    check if the root is empty
        if true then return root 
    run recursively left 
    if value < root.value 
        root.left = this.deleteNode(root.left, value) 
    run recursively right 
    elif value > root.value 
        root.right = this.deleteNode(root.right, value)
    check for if child is 0, 1, or 2 remove and reassign if needed 
    else 
        if root.L and root.R are null 
            return null
        if root.L is null 
            return root.R
        if root.R is null 
            return root.L 
        root.value is assigned to this.min(root.R)
        root.right = this.deleteNode(right, root.data)
    
    return root 
}


create a function that takes a value and return the node with the given value 
if there is no value then return false 
find(value) { 

}

create a function that accepst a a callback function as its parameter
The function should traverse the tree in breadth-first level order 
and call the callback on each node as it traverses, passing the whole node as an 
argument. If no callback then call a throw an error reporting a callback is required 

levelOrder(callBack){

}

create a function that takes a callback and  does the inorder depth-first order method 
pass each node through the callback

inOrder(callBack){
    
}

create a function that takes a callback and  does the preOrder depth-first order method 
pass each node through the callback


preOrder(callBack){
    
}

create a function that takes a callback and  does the postOrder depth-first order method 
pass each node through the callback


postOrder(callBack){
    
}

create a function that returns the given node's height;

height(node){ 

}

create a function that returns the given nodes' depth 

depth(node) {

}

create a function that checks if the tree is balanced 

isBalanced() {

}

create a function that rebalances a unblanaced tree

reblanace(){

}