Create a node class 
    constructor = > ( data )
    properties => { data, rightKid, leftKid }
build a tree class  
    constructor => ( array )
    properties => {root =  (returned value of the buildTree function) }

create a function that takes an array of data and turns it into a balanced 
binary tree full of Node objects appropitalely placed (dont forget to sort and remove
duplicates) The function should return the level - 0 root node 

buildTree(array)
    Set the middle of the array 
    let root is going to be the root node of tree 
    Recursively get middle of the left and right subtree
    Return root 

create a function that inserts the given value into the array being inserted 
insert(value , currentNode = this.root) { 
    if root is null return a new node with the value inside of it 
    if value is less than the root value ; run the insert method recursively for the left side of the root
        assign currentNode.left to the insert function with the value and currentNode left as the parameters 
    if value is more than the root value; run the insert method recursively for the right side of the root
        assign currentNode.right to the insert function with the value and currentNode right as the parameters 
    return currentNode 
}


create min function that returns the smallest value in the tree {

min(root) { 
    check root.left to see if it is null 
        if null then return the root.value 
        else return rootl.left recursively 
}

create max function that returns the largest value in the tree 

max(root) 
    check root.right to see if it is null 
    if null then return the root.value 
    else return the root.right recursively

create a function that will delete a node in the tree 
delete(value) { 
    assign root to run deleteNode function recursively with (root , value) as constructors 

}

deleteNode(value, root){ 

    check if the root is empty
    
    if value is less than root.data then run the method recursiviely left with value 
    
    else if value is more than root.data then run the method recrusively right with value 
    
    else 
        if root left is null then return the right sode the root 
        else if root right is null then return the left side of the root 
        else (AKA value and root data are equal) then root data becomes the min of root right
        right of root becomes a recursive with root = root.right and value = root.data 
    
    return root 
}


create a function that takes a value and return the node with the given value 
if there is no value then return false 
find(value) { 

}

create a function that accepst a a callback function as its parameter
The function should traverse the tree in breadth-first level order 
and call the callback on each node as it traverses, passing the whole node as an 
argument. If no callback then call a throw an error reporting a callback is required 

levelOrder(callBack){

}

create a function that takes a callback and  does the inorder depth-first order method 
pass each node through the callback

inOrder(callBack){
    
}

create a function that takes a callback and  does the preOrder depth-first order method 
pass each node through the callback


preOrder(callBack){
    
}

create a function that takes a callback and  does the postOrder depth-first order method 
pass each node through the callback


postOrder(callBack){
    
}

create a function that returns the given node's height;

height(node){ 

}

create a function that returns the given nodes' depth 

depth(node) {

}

create a function that checks if the tree is balanced 

isBalanced() {

}

create a function that rebalances a unblanaced tree

reblanace(){

}